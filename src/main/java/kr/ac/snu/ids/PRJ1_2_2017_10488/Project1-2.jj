options{  //keywords can be both upper or lower case  IGNORE_CASE = true;}PARSER_BEGIN(SimpleDBMSParser)package kr.ac.snu.ids.PRJ1_2_2017_10488;import java.io.UnsupportedEncodingException;import java.io.File;import java.util.*;import com.sleepycat.je.Database;import com.sleepycat.je.DatabaseException;import com.sleepycat.je.DatabaseConfig;import com.sleepycat.je.DatabaseEntry;import com.sleepycat.je.Cursor;import com.sleepycat.je.LockMode;import com.sleepycat.je.OperationStatus;import com.sleepycat.je.Environment;import com.sleepycat.je.EnvironmentConfig;public class SimpleDBMSParser{  //constants to distinguish query and print outputs.  public static final int PRINT_SYNTAX_ERROR = 0;  public static final int PRINT_CREATE_TABLE = 1;  public static final int PRINT_DROP_TABLE = 2;  public static final int PRINT_DESC = 3;  public static final int PRINT_INSERT = 4;  public static final int PRINT_DELETE = 5;  public static final int PRINT_SELECT = 6;  public static final int PRINT_SHOW_TABLES = 7;    // Environment & Database define  public static Environment myDbEnvironment = null;  public static Database myDatabase = null;    public static void main(String args[]) throws ParseException  {	/* Opening DB */    // Open Database Environment or if not, create one.    EnvironmentConfig envConfig = new EnvironmentConfig();    envConfig.setAllowCreate(true);    myDbEnvironment  = new Environment(new File("db/"), envConfig);    // Open Database or if not, create one.    DatabaseConfig dbConfig = new DatabaseConfig();    dbConfig.setAllowCreate(true);    dbConfig.setSortedDuplicates(false);    myDatabase  = myDbEnvironment.openDatabase(null, "sampleDatabase", dbConfig);    // Project 1-2 Parser
    SimpleDBMSParser parser = new SimpleDBMSParser(System.in);    // prompt when program starts    System.out.print("DB_2017-10488> ");        while (true)    {      try      {        parser.command();      }      catch (Exception e)      {        printMessage(PRINT_SYNTAX_ERROR);        SimpleDBMSParser.ReInit(System.in);        // prompt after syntax error        System.out.print("DB_2017-10488> ");      }    }  }  //not using any more...  public static void printMessage(int q)  {    //q is given by query() below    switch(q)    {      case PRINT_SYNTAX_ERROR:      	System.out.println("Syntax error");      	break;      case PRINT_CREATE_TABLE:      	System.out.println("\'CREATE TABLE\' requested");      	break;      case PRINT_DROP_TABLE:      	System.out.println("\'DROP TABLE\' requested");      	break;      case PRINT_DESC:      	System.out.println("\'DESC\' requested");      	break;      case PRINT_INSERT:      	System.out.println("\'INSERT\' requested");      	break;      case PRINT_DELETE:      	System.out.println("\'DELETE\' requested");      	break;      case PRINT_SELECT:      	System.out.println("\'SELECT\' requested");      	break;      case PRINT_SHOW_TABLES:      	System.out.println("\'SHOW TABLES\' requested");      	break;    }  }  //use simple string format to load and store data about schema  //cName, tName: alphabet_  //dataType: int or char(10) or date  //cnList: "cName,cName,cName" or "cName"  //tableConstraintDefinition: "pkc:cnList" or "fkc:cnList/tName/cnList"  //columnDefinition: "cName@dType#notnull" or "cName@dType"  //tableElement: "columnDefinition" or "tableConstraintDefinition"  //tableElementList: "tableElement" or "tableElement&tableElement&tableElement"  //split tableElementList using token  public static String[] teListToTes(String teList) {    String[] tes = teList.split("&");    return tes;  }  //get type of tableElement  //cd, pkc, fkc  public static String teType(String te) {	String[] temp = te.split(":");	if(temp.length == 1) {		return "cd";	}	return temp[0];  }  //split columnDefinition using token  public static String[] cdStruct(String cd) {    String[] struct = new String[3];	String[] nameType = cd.split("#")[0].split("@");	struct[0] = nameType[0];	struct[1] = nameType[1];	if(cd.contains("#")) {	  struct[2] = "notnull";	} else {	  struct[2] = "null";	}	return struct;  }  //true if there are wrongCharLength  public static boolean wrongCharLength(String teList) {	String[] tes = teListToTes(teList);    for(int i=0; i<tes.length; i++) {		if(teType(tes[i]).equals("cd")) {		  String[] cdStruct = cdStruct(tes[i]);		  String lenString = cdStruct[1];		  if(!lenString.startsWith("char")) {			continue;		  }		  lenString = lenString.substring(5, lenString.length()-1);		  int len = Integer.parseInt(lenString);		  if(len < 1) {			return true;		  }		}	}	return false;  }  //get type of cName col  public static String getColType(String cName, String teList) {    String[] tes = teListToTes(teList);    for(int i=0; i<tes.length; i++) {		if(teType(tes[i]).equals("cd")) {		  String[] cdStruct = cdStruct(tes[i]);		  if(cdStruct[0].equals(cName)) {			return cdStruct[1];		  }		}	}	return null;  }  //get index of cName col in teList  public static int getColIndex(String cName, String teList) {    String[] tes = teListToTes(teList);    for(int i=0; i<tes.length; i++) {		if(teType(tes[i]).equals("cd")) {		  String[] cdStruct = cdStruct(tes[i]);		  if(cdStruct[0].equals(cName)) {			return i;		  }		}	}	return -1;  }  //split cnLsit using token  public static String[] cnListStruct(String cnList) {	return cnList.split(",");  }  //get pkc's cnList  public static String[] pkCnList(String pkc) {	return cnListStruct(pkc.split(":")[1]);  }  //get pkc's cnList given teList, using uniqueness  public static String[] getPkc(String teList) {    String[] tes = teListToTes(teList);	for(int i=0; i<tes.length; i++) {		if(teType(tes[i]).equals("pkc")) {		  return pkCnList(tes[i]);		}	}	return null;  }  //get referencing cnList given fkc  public static String[] referencingCnList(String fkc) {    String[] temp = fkc.split(":")[1].split("/");    return cnListStruct(temp[0]);  }  //get referenced table name given fkc  public static String referencedTable(String fkc) {    String[] temp = fkc.split(":")[1].split("/");    return temp[1];  }  //get referenced cnList given fkc  public static String[] referencedCnList(String fkc) {    String[] temp = fkc.split(":")[1].split("/");    return cnListStruct(temp[2]);  }  //true if there are duplicated cName in cnList  public static boolean duplicatedCnList(String cnList) {	String[] cnListStruct = cnListStruct(cnList);	for(int i=0; i < cnListStruct.length-1; i++) {		for(int j = i+1; j < cnListStruct.length; j++) {			if(cnListStruct[i].equals(cnListStruct[j])) {				return true;			}		}	}	return false;  }  //get teList from db using tName  public static String getTeList(String tName) {		Cursor cursor = null;		DatabaseEntry key;		DatabaseEntry value;		String keyString = tName+"_schema";		try {		  cursor = myDatabase.openCursor(null, null);		  key = new DatabaseEntry(keyString.getBytes("UTF-8"));		  value = new DatabaseEntry();		  OperationStatus retVal = cursor.getSearchKey(key, value, LockMode.DEFAULT);		  if(retVal == OperationStatus.SUCCESS) {		    String ret = new String(value.getData(), "UTF-8");		    cursor.close();		    return ret;		  }		} catch (Exception e) {		} finally {		  cursor.close();		}		return null;  }  //get cnList of columns given teList  public static String getCnList(String teList) {	String[] tes = teListToTes(teList);	String cnList = "";    for(int i=0; i<tes.length; i++) {		if(teType(tes[i]).equals("cd")) {		  String[] cdStruct = cdStruct(tes[i]);		  cnList = cnList + cdStruct[0] + ",";		}	}	return cnList.substring(0, cnList.length()-1);  }  //true if there are duplicated columns given teList  public static boolean duplicatedCols(String teList) {	String[] tes = teListToTes(teList);	String cnList = getCnList(teList);	return duplicatedCnList(cnList);  }  //true if there are duplicated pkc given teList  public static boolean duplicatedPkDefine(String teList) {	String[] tes = teListToTes(teList);	int count = 0;	for(int i=0; i<tes.length; i++) {		if(teType(tes[i]).equals("pkc")) {			count++;		}	}	return count > 1;  }  //true if there are table named tName in DB  public static boolean isTableExist(String tName) {		Cursor cursor = null;		DatabaseEntry key;		DatabaseEntry value;		String keyString = tName+"_schema";		try {		  cursor = myDatabase.openCursor(null, null);		  key = new DatabaseEntry(keyString.getBytes("UTF-8"));		  value = new DatabaseEntry();		  OperationStatus retVal = cursor.getSearchKey(key, value, LockMode.DEFAULT);		  if(retVal == OperationStatus.SUCCESS) {		    cursor.close();		    return true;		  }		} catch (Exception e) {		} finally {		  cursor.close();		}		return false;  }  //true if table named tName is referenced by any one  public static boolean isTableReferenced(String tName) {		String suffix = "_ref_"+tName;		Cursor cursor = null;		DatabaseEntry foundKey;		DatabaseEntry foundValue;		try {		  cursor = myDatabase.openCursor(null, null);		  foundKey = new DatabaseEntry();	      foundValue = new DatabaseEntry();	      cursor.getFirst(foundKey, foundValue, LockMode.DEFAULT);	      do {	      	String keyString = new String(foundKey.getData(), "UTF-8");	      	String valueString = new String(foundValue.getData(), "UTF-8");	      	if(keyString.endsWith(suffix)) {	      	  cursor.close();	      	  return true;	      	}	      } while (cursor.getNext(foundKey, foundValue, LockMode.DEFAULT) == OperationStatus.SUCCESS);		} catch (Exception e) {		} finally {		  cursor.close();		}		return false;  }  //used for show tables formating  public static String addTab(String output) {	int howManySpace = 30 - output.length();	for(int i=0; i<howManySpace; i++) {		output = output + " ";	}	return output;  }}PARSER_END(SimpleDBMSParser)SKIP : { < SPACE: " " > | <  TAB : "\t" > | < EOL : "\r\n" | "\n" | "\r" > }//key word on top of < LEGAL_IDENTIFIER > so keyword is detected firstTOKEN : /* Keywords */{  < EXIT : "exit" >| < INT : "int" >| < CHAR : "char" >| < DATE : "date" >| < CREATE : "create" >| < TABLE : "table" >| < DROP : "drop" >| < DESC : "desc" >| < INSERT : "insert" >| < INTO : "into" >| < DELETE : "delete" >| < SELECT : "select" >| < SHOW : "show" >| < TABLES : "tables" >| < VALUES : "values" >| < WHERE : "where" >| < PRIMARY : "primary" >| < FOREIGN : "foreign" >| < KEY : "key" >| < REFERENCES : "references" >| < NULL : "null" >| < NOT : "not" >| < OR : "or" >| < AS : "as" >| < FROM : "from" >| < AND : "and" >| < IS : "is" >| < ASTERISK : "*" >}//building blocks for the functions belowTOKEN :	//used in functions{  < END : < SEMICOLON >(< SPACE > | < TAB >)*< EOL >>| < SEMICOLON : ";" >| < LEFT_PAREN : "(" >| < RIGHT_PAREN : ")" >| < COMMA : "," >| < PERIOD : "." >| < COMP_OP : ">" | "<" | ">=" | "<=" | "!=" | "=" >| < INT_VALUE : (< SIGN >)? (< DIGIT >)+>| < LEGAL_IDENTIFIER : < ALPHABET > (< ALPHABET > | < UNDERSCORE >)* >| < DATE_VALUE : < NNNN >"-"< NN >"-"< NN > >| < CHAR_STRING : < QUOTE >(< NON_QUOTE_CHARACTER >)*< QUOTE > >}//used to make token block aboveTOKEN :	//used to make token{  < NNNN : < DIGIT >< DIGIT >< DIGIT >< DIGIT > >| < NN : < DIGIT >< DIGIT > >| < ALPHABET : [ "a"-"z", "A"-"Z" ] >| < SIGN : "+" | "-" >	| < DIGIT : [ "0"-"9" ] >| < UNDERSCORE : "_" >| < QUOTE : "'" >| < NON_QUOTE_SPECIAL_CHARACTERS: "!" | "@" | "#" | "$" | "%" | "^" | "&" | "-" | "{" | "}" | "[" | "]" |									"~" | "`" | "+" | "*" | "_" | "=" | "\\" | "(" | ")" | "<" | ">" |									"?" | "," | "." | "\n" | "\t" | "\r" | ":" | ";" | "|" | "/">| < NON_QUOTE_CHARACTER : < DIGIT > | < ALPHABET > | < NON_QUOTE_SPECIAL_CHARACTERS > | < SPACE > >| < UNEXPECTED:~[] >}void command() :{}{  (  	queryList()  )| (    < EXIT >    (    	< SEMICOLON > | < END > 	)    {      // Close DB before exit      if (myDatabase != null) myDatabase.close();  	  if (myDbEnvironment != null) myDbEnvironment.close();      System.exit(0);    }  )}void queryList() :{  String q;}{  (    q = query()    (  	    (	      //when query ends at end of line	      < END >		  	{		  	  System.out.println(q);		  	  //prompt when new query starts		  	  System.out.print("DB_2017-10488> ");		  	}		)	  | (	   		//for query sequence with semicolon concatenated with another query		  < SEMICOLON >		    {		      System.out.println(q);		 	}		)	)  )+}String query() :{  String q = "default";}{  //query returns q, which is used to print correct message by System.out.println(q) in queryList()  (    (      	q = createTableQuery()	    {}	  )	| (	  	q = dropTableQuery()	  	{}	  )	| (	  	q = descQuery()	  	{}	  )	| (	  	insertQuery()	  	{	  	  //q = PRINT_INSERT;	  	}	  )	| (	  	deleteQuery()	  	{	  	  //q = PRINT_DELETE;	  	}	  )	| (	  	selectQuery()	  	{	  	  //q = PRINT_SELECT;	  	}	  )	| (	  	q = showTablesQuery()	  	{} 	  )	)  {   	return q;  }}//below regex for queries are similar to the ones in grammar file. /// 0. easy onesString dropTableQuery() :{String tName;}{	<  DROP >	< TABLE >	tName = tableName() {		Cursor cursor = null;		DatabaseEntry key;		DatabaseEntry value;		//target key to be found		String keyString = tName+"_schema";		String ret = "exception on drop";		try {		  cursor = myDatabase.openCursor(null, null);		  key = new DatabaseEntry(keyString.getBytes("UTF-8"));		  value = new DatabaseEntry();		  OperationStatus retVal = cursor.getSearchKey(key, value, LockMode.DEFAULT);		  if(retVal == OperationStatus.NOTFOUND) {		    //no table		    ret = "No such table";		  } else if(isTableReferenced(tName)) {		    //table referenced			ret = "Drop table has failed: '"+tName+"' is referenced by other table";		  } else {		    //successful case		    cursor.delete();			ret = "'"+tName+"'"+" table is dropped";			//delete reference data from tName			String prefix = tName+"_ref_";			DatabaseEntry foundKey;			DatabaseEntry foundValue;			foundKey = new DatabaseEntry();		    foundValue = new DatabaseEntry();		    cursor.getFirst(foundKey, foundValue, LockMode.DEFAULT);		    do {		      	String keyStringFound = new String(foundKey.getData(), "UTF-8");		      	String valueString = new String(foundValue.getData(), "UTF-8");		      	if(keyStringFound.startsWith(prefix)) {		      	  cursor.delete();		      	}		    } while (cursor.getNext(foundKey, foundValue, LockMode.DEFAULT) == OperationStatus.SUCCESS);		  }		} catch (Exception e) {		} finally {		  cursor.close();		}		return ret;	}}String descQuery() :{String tName;}{	< DESC >	tName = tableName() {	  	Cursor cursor = null;		DatabaseEntry key;		DatabaseEntry value;		//target key to be found		String keyString = tName+"_schema";		String ret = "exception on desc";		try {		  cursor = myDatabase.openCursor(null, null);		  key = new DatabaseEntry(keyString.getBytes("UTF-8"));		  value = new DatabaseEntry();		  OperationStatus retVal = cursor.getSearchKey(key, value, LockMode.DEFAULT);		  if(retVal == OperationStatus.NOTFOUND) {		    //no table		    ret = "No such table";		  } else {		    String teList = new String(value.getData(), "UTF-8");		    String[] tes = teListToTes(teList);		    String[] types = new String[tes.length];		    String[] nulls = new String[tes.length];		    String[] keys = new String[tes.length];			for(int i = 0; i < tes.length; i++) {		      String type = teType(tes[i]);		      //dealing with pkc		      if(type.equals("pkc")) {		        String pkc = tes[i];		        String[] cnList = pkCnList(pkc);		        for(int j=0; j<cnList.length; j++) {		          int index = getColIndex(cnList[j], teList);		          // PRI implies not null		          nulls[index] = "notnull";		          types[index] = "PRI";		        }		      } else if(type.equals("fkc")) {		        //dealing with fkc		        String fkc = tes[i];		        String[] referencing = referencingCnList(fkc);				for(int j=0; j<referencing.length; j++) {					int index = getColIndex(referencing[j], teList);					if(types[index] == null) {						types[index] = "FOR";					} else {						types[index] = types[index] + "/FOR";					}				}		      }    		}    		String tab = "               ";		    ret = "-------------------------------------------------\n";			ret = ret + "table_name ["+tName+"]\n";			ret = ret + addTab("column_name")+addTab("type")+addTab("null")+"key\n";    		for(int i = 0; i < tes.length; i++) {			  String type = teType(tes[i]);		      if(type.equals("cd")) {				String[] cdStruct = cdStruct(tes[i]);				if(nulls[i] != null) {					cdStruct[2] = nulls[i];				}				// cdStruct = [name, type, notnull or null]				ret = ret + addTab(cdStruct[0]) + addTab(cdStruct[1]) + addTab(cdStruct[2].equals("notnull") ? "N" : "Y") + (types[i] == null ? "\n" : (types[i]+"\n"));		      }    		}    		ret = ret + "-------------------------------------------------";		  }		} catch (Exception e) {		} finally {		  cursor.close();		}		return ret;	}}String showTablesQuery() :{}{	< SHOW>	< TABLES > {	  	Cursor cursor = null;		DatabaseEntry foundKey;		DatabaseEntry foundValue;		int count = 0;		String ret = "----------------\n";		try {		  cursor = myDatabase.openCursor(null, null);		  foundKey = new DatabaseEntry();	      foundValue = new DatabaseEntry();	      cursor.getFirst(foundKey, foundValue, LockMode.DEFAULT);	      do {	      	String keyString = new String(foundKey.getData(), "UTF-8");	      	String valueString = new String(foundValue.getData(), "UTF-8");	      	if(keyString.endsWith("_schema")) {	      	    //table schema found	      	    //eliminate suffix	      	  	String tName = keyString.substring(0, keyString.length() - 7);				ret = ret + tName + "\n";				count++;	      	}	      } while (cursor.getNext(foundKey, foundValue, LockMode.DEFAULT) == OperationStatus.SUCCESS);		} catch (Exception e) {		} finally {		  cursor.close();		}		ret = ret + "----------------";		if(count == 0) {			ret = "There is no table";		}		return ret;	}}/// 0. easy ones /// 1. for createTableQuery()String createTableQuery() :{String tName; String teList;}{  (    < CREATE >  < TABLE >  tName = tableName()  teList = tableElementList()  ){    if(isTableExist(tName)) {		return "Create table has failed: table with the same name already exists";    }    if(duplicatedCols(teList)) {		return "Create table has failed: column definition is duplicated";    }    if(wrongCharLength(teList)) {		return "Char length should be over 0";    }    if(duplicatedPkDefine(teList)) {		return "Create table has failed: primary key definition is duplicated";    }    //for storing reference data to DB    ArrayList<String> referencedTables = new ArrayList<String>();    String[] tes = teListToTes(teList);    for(int i = 0; i < tes.length; i++) {      String type = teType(tes[i]);      if(type.equals("pkc")) {        //examination on pkc        String pkc = tes[i];        String[] cnList = pkCnList(pkc);        for(int j=0; j<cnList.length; j++) {			String colType = getColType(cnList[j], teList);			if(colType == null) {			  return "Create table has failed: '"+cnList[j]+"' does not exists in column definition";			}        }      } else if(type.equals("fkc")) {        //examination on fkc        String fkc = tes[i];        String[] referencing = referencingCnList(fkc);		String[] referenced = referencedCnList(fkc);		String referencedTName = referencedTable(fkc);		if(!isTableExist(referencedTName)) {			return "Create table has failed: foreign key references non existing table";		}		for(int j=0; j<referencing.length; j++) {			String colType = getColType(referencing[j], teList);			if(colType == null) {			  return "Create table has failed: '"+referencing[j]+"' does not exists in column definition";			}		}		String referencedTeList = getTeList(referencedTName);		for(int j=0; j<referenced.length; j++) {			String colType = getColType(referenced[j], referencedTeList);			if(colType == null) {			  return "Create table has failed: foreign key references non existing column";			}		}		if(referencing.length != referenced.length) {			return "Create table has failed: foreign key references wrong type";		}		//Assume that referencing and referenced column lists are in same order		for(int j=0; j<referencing.length; j++) {			String colType1 = getColType(referencing[j], teList);			String colType2 = getColType(referenced[j], referencedTeList);			if(!colType1.equals(colType2)) {			  return "Create table has failed: foreign key references wrong type";			}		}		String[] referencedPk = getPkc(referencedTeList);		if(referencedPk == null) {			return "Create table has failed: foreign key references non primary key column";		}		if(referenced.length != referencedPk.length) {			return "Create table has failed: foreign key references non primary key column";		}		for(int j=0; j<referenced.length; j++) {		  	boolean ok = false;			for(int k=0; k<referencedPk.length; k++) {			  if(referenced[j].equals(referencedPk[k])) {				ok = true;			  }			}			if(!ok) {			  return "Create table has failed: foreign key references non primary key column";			}		}		referencedTables.add(referencedTName);      }    }    // Store table schema to DB	Cursor cursor = null;	DatabaseEntry key;	DatabaseEntry value;	String keyString = tName + "_schema";		try {	  cursor = myDatabase.openCursor(null, null);	  key = new DatabaseEntry(keyString.getBytes("UTF-8"));	  value = new DatabaseEntry(teList.getBytes("UTF-8"));	  cursor.put(key, value);	} catch (Exception e) {	} finally {	  cursor.close();	}	// Store referencing info	for(int i=0; i < referencedTables.size(); i++) {		String tNameKey = tName+"_ref_"+referencedTables.get(i);		try {		  cursor = myDatabase.openCursor(null, null);		  key = new DatabaseEntry(tNameKey.getBytes("UTF-8"));		  value = new DatabaseEntry("true".getBytes("UTF-8"));		  cursor.put(key, value);		} catch (Exception e) {		} finally {		  cursor.close();		}	}	return "'"+tName+"'"+" table is created";  }}String tableElementList() :{String tList = null; String elem = null;}{  < LEFT_PAREN >  elem = tableElement() { tList = elem; }  (    < COMMA >    elem = tableElement() { tList = tList + "&" + elem; }  )*  < RIGHT_PAREN > { return tList; }}String tableElement() :{String ret = null;}{  ret = columnDefinition() { return ret; }| ret = tableConstraintDefinition() { return ret; }}String columnDefinition() :{String cName = null; String dType = null; String ret = null;}{  (	  cName = columnName() { ret = cName; }	  dType = dataType() { ret = ret + "@" + dType;}	  (	    < NOT >	    < NULL > { ret = ret + "#" + "notnull"; }	  )?  ) { return ret; }}String tableConstraintDefinition() :{String constraint = null;}{  constraint = primaryKeyConstraint() { return "pkc:"+constraint; }| constraint = referentialConstraint() { return "fkc:"+constraint; }}String primaryKeyConstraint() :{String cnList = null;}{  < PRIMARY >  < KEY >  cnList = columnNameList() { return cnList; }}String referentialConstraint() :{String ret = null; String cnList = null; String tName = null;}{  < FOREIGN >  < KEY >  cnList = columnNameList() { ret = cnList;}  < REFERENCES >  tName = tableName() { ret = ret + "/" + tName; }  cnList = columnNameList() { ret = ret + "/" + cnList; return ret; }}String columnNameList() :{String cnList = null; String cName;}{  < LEFT_PAREN >  cName = columnName() { cnList = cName; }  (    < COMMA >    cName = columnName() { cnList = cnList + "," + cName; }  )*  < RIGHT_PAREN > { return cnList; }}String dataType() :{Token t; Token len;}{  t = < INT > { return t.toString(); }| (    t = < CHAR >    < LEFT_PAREN >    len = < INT_VALUE >    < RIGHT_PAREN >  ) { return t.toString()+"("+len.toString()+")"; }| t = < DATE > { return t.toString(); }}//ignoring alphabet case, just convert to lower caseString tableName() :{Token t;}{  t = < LEGAL_IDENTIFIER > { return t.toString().toLowerCase(); }}String columnName() :{Token t;}{  t = < LEGAL_IDENTIFIER > { return t.toString().toLowerCase(); }}/// 1. for createTableQuery/// 2. for selectQueryvoid selectQuery() :{}{	< SELECT >	selectList()	tableExpression()}void selectList() :{}{  < ASTERISK >| (  	selectedColumn()  	(  	  < COMMA >  	  selectedColumn()  	)*  )}void selectedColumn() :{}{	(	  //tableName & columnName are same token <LEGAL_IDENITFIER >, so need to lookahead 2	  LOOKAHEAD(2)	  tableName()	  < PERIOD >	)?	columnName()	(	  < AS >	  columnName()	)?}void tableExpression():{}{	fromClause()	(		whereClause()	)?}void fromClause():{}{  < FROM >  tableReferenceList()}void tableReferenceList():{}{  referedTable()  (    < COMMA >    referedTable()  )*}void referedTable():{}{  tableName()  (    < AS >    tableName()  )?}void whereClause() :{}{  < WHERE >  booleanValueExpression()}void booleanValueExpression() :{}{  booleanTerm()  (    < OR >    booleanTerm()  )*}void booleanTerm():{}{  booleanFactor()  (    < AND >    booleanFactor()  )*}void booleanFactor():{}{  (    < NOT >  )?  booleanTest()}void booleanTest():{}{  predicate()| parenthesizedBooleanExpression()}void parenthesizedBooleanExpression():{}{  < LEFT_PAREN >  booleanValueExpression()  < RIGHT_PAREN >}void predicate():{}{  //comparisonPredicate & nullPredicate can both start with tableName()< PERIOD >columnName()  //so need to lookahead 4  LOOKAHEAD(4)  comparisonPredicate()| nullPredicate() }void comparisonPredicate():{}{	compOperand()	< COMP_OP >	compOperand() }void compOperand():{}{  comparableValue()| (  	(  	  //tableName & columnName are same token <LEGAL_IDENITFIER >, so need to lookahead 2  	  LOOKAHEAD(2)  	  tableName()  	  < PERIOD >  	)?  	columnName() )}void comparableValue():{}{  < INT_VALUE >| < CHAR_STRING >| < DATE_VALUE >}void nullPredicate():{}{  (    //tableName & columnName are same token <LEGAL_IDENITFIER >, so need to lookahead 2    LOOKAHEAD(2)    tableName()    < PERIOD >  )?  columnName()  nullOperation()}void nullOperation():{}{  < IS >  (    (      < NOT >    )?  	< NULL >  )}/// 2. for selectQuery/// 3. for insert,deletevoid insertQuery() :{}{	< INSERT >	< INTO >	tableName()	insertColumnsAndSource()}void deleteQuery() :{}{	< DELETE >	< FROM > 	tableName()	(		whereClause()	)?}void insertColumnsAndSource() :{}{	(	  columnNameList()	)?	valueList()}void valueList() :{}{	< VALUES >	< LEFT_PAREN >	value()	(	  < COMMA >	  value()	)*	< RIGHT_PAREN >}void value() :{}{	< NULL >|  comparableValue()}/// 3. for insert,delete